# -*- coding: utf-8 -*-
"""Vindiata Consulting Private Limited Task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x8iFv2B_PdwdrihBsAeVUNlGb0xlZ3rn
"""

import pandas as pd

from google.colab import files
uploaded = files.upload()

import pandas as pd

# Replace with your uploaded filename
excel_path = "Analytics Position Case Study.xlsx"

# Load all sheets as a dictionary of DataFrames
all_sheets = pd.read_excel(excel_path, sheet_name=None)

# List all sheet names
print(" Sheets in the Excel File:")
for sheet_name in all_sheets.keys():
    print(f"- {sheet_name}")

# Assign to separate DataFrames
gameplay_df = all_sheets['User Gameplay data']
deposit_df = all_sheets['Deposit Data']
withdrawal_df = all_sheets['Withdrawal Data']

print( "Gameplay Data:")
display(gameplay_df.head())

print(" Deposit Data:")
display(deposit_df.head())

print(" Withdrawal Data:")
display(withdrawal_df.head())

print("\n Gameplay Data Info:")
gameplay_df.info()

print("\n Deposit Data Info:")
deposit_df.info()

print("\n Withdrawal Data Info:")
withdrawal_df.info()



# Reload the three clean sheets, skipping the header description
gameplay_df = pd.read_excel(excel_path, sheet_name='User Gameplay data', skiprows=3)
deposit_df = pd.read_excel(excel_path, sheet_name='Deposit Data', skiprows=3)
withdrawal_df = pd.read_excel(excel_path, sheet_name='Withdrawal Data', skiprows=3)

# Preview
print(" Gameplay:")
display(gameplay_df.head())

print(" Deposit:")
display(deposit_df.head())

print("Withdrawal:")
display(withdrawal_df.head())

import pandas as pd

# Convert Datetime column to datetime type
gameplay_df['Datetime'] = pd.to_datetime(gameplay_df['Datetime'])
deposit_df['Datetime'] = pd.to_datetime(deposit_df['Datetime'])
withdrawal_df['Datetime'] = pd.to_datetime(withdrawal_df['Datetime'])

# Add 'Date', 'Hour', 'Slot' columns
def assign_slot(hour):
    return 'S1' if hour < 12 else 'S2'

# For Gameplay
gameplay_df['Date'] = gameplay_df['Datetime'].dt.date
gameplay_df['Hour'] = gameplay_df['Datetime'].dt.hour
gameplay_df['Slot'] = gameplay_df['Hour'].apply(assign_slot)

# For Deposit
deposit_df['Date'] = deposit_df['Datetime'].dt.date
deposit_df['Hour'] = deposit_df['Datetime'].dt.hour
deposit_df['Slot'] = deposit_df['Hour'].apply(assign_slot)

# For Withdrawal
withdrawal_df['Date'] = withdrawal_df['Datetime'].dt.date
withdrawal_df['Hour'] = withdrawal_df['Datetime'].dt.hour
withdrawal_df['Slot'] = withdrawal_df['Hour'].apply(assign_slot)

# ✅ Check few rows from each
print(" Gameplay Updated:")
display(gameplay_df.head())

print(" Deposit Updated:")
display(deposit_df.head())

print(" Withdrawal Updated:")
display(withdrawal_df.head())

from datetime import date

# Define the target date and slot
target_date = date(2022, 10, 2)
target_slot = 'S1'

#  Gameplay: filter, group, and aggregate
gameplay_filtered = gameplay_df[(gameplay_df['Date'] == target_date) & (gameplay_df['Slot'] == target_slot)]
games_played = gameplay_filtered.groupby('User ID')['Games Played'].sum().reset_index()

#  Deposit: filter, group, and aggregate
deposit_filtered = deposit_df[(deposit_df['Date'] == target_date) & (deposit_df['Slot'] == target_slot)]
deposit_stats = deposit_filtered.groupby('User Id').agg(
    Total_Deposit_Amount=('Amount', 'sum'),
    Deposit_Count=('Amount', 'count')
).reset_index()

#  Withdrawal: filter, group, and aggregate
withdrawal_filtered = withdrawal_df[(withdrawal_df['Date'] == target_date) & (withdrawal_df['Slot'] == target_slot)]
withdrawal_stats = withdrawal_filtered.groupby('User Id').agg(
    Total_Withdrawal_Amount=('Amount', 'sum'),
    Withdrawal_Count=('Amount', 'count')
).reset_index()

#  Merge all three
merged = pd.merge(games_played, deposit_stats, left_on='User ID', right_on='User Id', how='outer')
merged = pd.merge(merged, withdrawal_stats, on='User Id', how='outer')

#  Fill NaN with 0 (in case of missing activity)
merged.fillna(0, inplace=True)

#  Loyalty Calculation

merged['Loyalty Points'] = (
    0.01 * merged['Total_Deposit_Amount'] +
    0.005 * merged['Total_Withdrawal_Amount'] +
    0.001 * merged.apply(lambda x: max(x['Deposit_Count'] - x['Withdrawal_Count'], 0), axis=1) +
    0.2 * merged['Games Played']
)

#  Final result
result_q1a = merged[['User ID', 'Loyalty Points']].sort_values(by='Loyalty Points', ascending=False).reset_index(drop=True)
display(result_q1a.head(10))  # Show top 10 for now

# Check counts of entries for each dataset on 2 Oct, Slot S1
print(" Gameplay entries:", gameplay_df[(gameplay_df['Date'] == target_date) & (gameplay_df['Slot'] == target_slot)].shape[0])
print(" Deposit entries:", deposit_df[(deposit_df['Date'] == target_date) & (deposit_df['Slot'] == target_slot)].shape[0])
print(" Withdrawal entries:", withdrawal_df[(withdrawal_df['Date'] == target_date) & (withdrawal_df['Slot'] == target_slot)].shape[0])

def calculate_loyalty_points(target_date, target_slot):
    from datetime import datetime

    # Filter Gameplay
    gp = gameplay_df[(gameplay_df['Date'] == target_date) & (gameplay_df['Slot'] == target_slot)]
    gp_grouped = gp.groupby('User ID')['Games Played'].sum().reset_index()

    # Filter Deposit
    dp = deposit_df[(deposit_df['Date'] == target_date) & (deposit_df['Slot'] == target_slot)]
    dp_grouped = dp.groupby('User Id').agg(
        Total_Deposit_Amount=('Amount', 'sum'),
        Deposit_Count=('Amount', 'count')
    ).reset_index()

    # Filter Withdrawal
    wd = withdrawal_df[(withdrawal_df['Date'] == target_date) & (withdrawal_df['Slot'] == target_slot)]
    wd_grouped = wd.groupby('User Id').agg(
        Total_Withdrawal_Amount=('Amount', 'sum'),
        Withdrawal_Count=('Amount', 'count')
    ).reset_index()

    # Merge
    merged = pd.merge(gp_grouped, dp_grouped, left_on='User ID', right_on='User Id', how='outer')
    merged = pd.merge(merged, wd_grouped, on='User Id', how='outer')
    merged.fillna(0, inplace=True)

    # Calculate loyalty
    merged['Loyalty Points'] = (
        0.01 * merged['Total_Deposit_Amount'] +
        0.005 * merged['Total_Withdrawal_Amount'] +
        0.001 * merged.apply(lambda x: max(x['Deposit_Count'] - x['Withdrawal_Count'], 0), axis=1) +
        0.2 * merged['Games Played']
    )

    result = merged[['User ID', 'Loyalty Points']].sort_values(by='Loyalty Points', ascending=False).reset_index(drop=True)
        # Replace missing 'User ID' with 'User Id' where possible
    merged['User ID'] = merged.apply(lambda x: x['User ID'] if x['User ID'] != 0 else x['User Id'], axis=1)

    # Clean result table
    result = merged[['User ID', 'Loyalty Points']].drop_duplicates().sort_values(by='Loyalty Points', ascending=False).reset_index(drop=True)

    return result

from datetime import date

# Question 1b: 16th October, Slot S2
result_q1b = calculate_loyalty_points(date(2022, 10, 16), 'S2')
display(result_q1b.head(10))

# Q1c: 18th October – Slot S1
result_q1c = calculate_loyalty_points(date(2022, 10, 18), 'S1')
display(result_q1c.head(10))

# Q1d: 26th October – Slot S2
result_q1d = calculate_loyalty_points(date(2022, 10, 26), 'S2')
display(result_q1d.head(10))

""" Q2 – Monthly Loyalty Leaderboard"""



# Convert Date columns to datetime
gameplay_df['Date'] = pd.to_datetime(gameplay_df['Date'])
deposit_df['Date'] = pd.to_datetime(deposit_df['Date'])
withdrawal_df['Date'] = pd.to_datetime(withdrawal_df['Date'])

# Filter October data
oct_gameplay = gameplay_df[gameplay_df['Date'].dt.month == 10]
oct_deposit = deposit_df[deposit_df['Date'].dt.month == 10]
oct_withdrawal = withdrawal_df[withdrawal_df['Date'].dt.month == 10]

# Group by user
gp_group = oct_gameplay.groupby('User ID')['Games Played'].sum().reset_index()

dp_group = oct_deposit.groupby('User Id').agg(
    Total_Deposit_Amount=('Amount', 'sum'),
    Deposit_Count=('Amount', 'count')
).reset_index()

wd_group = oct_withdrawal.groupby('User Id').agg(
    Total_Withdrawal_Amount=('Amount', 'sum'),
    Withdrawal_Count=('Amount', 'count')
).reset_index()

# Merge
merged_month = pd.merge(gp_group, dp_group, left_on='User ID', right_on='User Id', how='outer')
merged_month = pd.merge(merged_month, wd_group, on='User Id', how='outer')
merged_month.fillna(0, inplace=True)

# Loyalty Point Calculation
merged_month['Loyalty Points'] = (
    0.01 * merged_month['Total_Deposit_Amount'] +
    0.005 * merged_month['Total_Withdrawal_Amount'] +
    0.001 * merged_month.apply(lambda x: max(x['Deposit_Count'] - x['Withdrawal_Count'], 0), axis=1) +
    0.2 * merged_month['Games Played']
)

# Fix User ID column
merged_month['User ID'] = merged_month.apply(
    lambda x: x['User ID'] if x['User ID'] != 0 else x['User Id'], axis=1
)

# Final Sorted Leaderboard
monthly_leaderboard = merged_month[['User ID', 'Loyalty Points', 'Games Played']].drop_duplicates()
monthly_leaderboard = monthly_leaderboard.sort_values(
    by=['Loyalty Points', 'Games Played'], ascending=[False, False]
).reset_index(drop=True)

display(monthly_leaderboard.head(10))  # top 10



"""Q3. What is the average deposit amount?"""

average_deposit = deposit_df['Amount'].mean()
print(f"Average deposit amount: ₹{average_deposit:.2f}")



""" Q4. What is the average deposit amount per user in October?"""

oct_deposit_per_user = oct_deposit.groupby('User Id')['Amount'].sum()
average_deposit_per_user = oct_deposit_per_user.mean()
print(f" Average deposit amount per user (Oct): ₹{average_deposit_per_user:.2f}")



"""Q5. What is the average number of games played per user?


"""

games_per_user = gameplay_df.groupby('User ID')['Games Played'].sum()
average_games_per_user = games_per_user.mean()
print(f" Average number of games played per user: {average_games_per_user:.2f}")





"""Par B: Bonus Allocation

"""

# Step 1: Filter top 50 players from existing leaderboard
top_50 = monthly_leaderboard.head(50).copy()

# Step 2: Total loyalty points of Top 50
total_loyalty_top_50 = top_50['Loyalty Points'].sum()

# Step 3: Calculate bonus proportionally
top_50['Bonus (₹)'] = (top_50['Loyalty Points'] / total_loyalty_top_50) * 50000
top_50['Bonus (₹)'] = top_50['Bonus (₹)'].round(2)

# Step 4: Display result
display(top_50.head(10))  # Display top 10 rows from Top 50 bonus winners